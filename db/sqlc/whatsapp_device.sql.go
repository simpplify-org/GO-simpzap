// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: whatsapp_device.sql

package db

import (
	"context"
	"database/sql"
)

const getDevice = `-- name: GetDevice :one
SELECT id, number, container_id, endpoint, version, active, created_at, updated_at, updated_who FROM whatsapp_device
WHERE number = $1 AND active = TRUE
`

func (q *Queries) GetDevice(ctx context.Context, number string) (WhatsappDevice, error) {
	row := q.db.QueryRowContext(ctx, getDevice, number)
	var i WhatsappDevice
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.ContainerID,
		&i.Endpoint,
		&i.Version,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedWho,
	)
	return i, err
}

const getDevices = `-- name: GetDevices :many
SELECT id, number, container_id, endpoint, version, active, created_at, updated_at, updated_who FROM whatsapp_device
WHERE active = TRUE
`

func (q *Queries) GetDevices(ctx context.Context) ([]WhatsappDevice, error) {
	rows, err := q.db.QueryContext(ctx, getDevices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WhatsappDevice
	for rows.Next() {
		var i WhatsappDevice
		if err := rows.Scan(
			&i.ID,
			&i.Number,
			&i.ContainerID,
			&i.Endpoint,
			&i.Version,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedWho,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteDevice = `-- name: SoftDeleteDevice :exec
UPDATE whatsapp_device
SET active = FALSE
WHERE number = $1 AND active = TRUE
`

func (q *Queries) SoftDeleteDevice(ctx context.Context, number string) error {
	_, err := q.db.ExecContext(ctx, softDeleteDevice, number)
	return err
}

const upsertDevice = `-- name: UpsertDevice :one
INSERT INTO whatsapp_device (number, container_id, endpoint, version, updated_who)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (number)
DO UPDATE SET
    container_id = EXCLUDED.container_id,
    endpoint = EXCLUDED.endpoint,
    version = EXCLUDED.version,
    updated_who = EXCLUDED.updated_who,
    updated_at = NOW()
RETURNING id
`

type UpsertDeviceParams struct {
	Number      string         `json:"number"`
	ContainerID string         `json:"container_id"`
	Endpoint    string         `json:"endpoint"`
	Version     sql.NullString `json:"version"`
	UpdatedWho  sql.NullString `json:"updated_who"`
}

func (q *Queries) UpsertDevice(ctx context.Context, arg UpsertDeviceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertDevice,
		arg.Number,
		arg.ContainerID,
		arg.Endpoint,
		arg.Version,
		arg.UpdatedWho,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}
